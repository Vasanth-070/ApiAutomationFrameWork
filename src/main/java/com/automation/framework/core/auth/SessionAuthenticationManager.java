package com.automation.framework.core.auth;

import com.automation.framework.core.config.ApiConfig;
import com.automation.framework.core.interfaces.LoggingInterface;
import com.automation.framework.core.logging.ApiLogger;
import io.restassured.RestAssured;
import io.restassured.specification.RequestSpecification;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Map;
import java.util.HashMap;

/**
 * Session-based Authentication Manager that ensures single token generation per session
 * Integrates with BaseApiTest for seamless authentication handling
 */
public class SessionAuthenticationManager {
    private static final LoggingInterface logger = new ApiLogger(SessionAuthenticationManager.class);
    
    // Singleton instance for session-wide authentication
    private static volatile SessionAuthenticationManager instance;
    private static final ReentrantLock lock = new ReentrantLock();
    
    // Session cache for authentication tokens
    private final ConcurrentHashMap<String, SessionAuthData> sessionCache = new ConcurrentHashMap<>();
    
    // REST Assured session-aware request specification for automatic cookie handling
    private RequestSpecification sessionSpec;
    
    private final AuthenticationManager authManager;
    private final ApiConfig apiConfig;
    
    // Configuration keys for authentication properties
    private static final String PROP_AUTH_USER_EMAIL = "auth.user.email";
    private static final String PROP_AUTH_USER_PHONE = "auth.user.phone";
    private static final String PROP_AUTH_USER_CLIENT_ID = "auth.user.clientid";
    private static final String PROP_AUTH_USER_DEVICE_ID = "auth.user.device.id";
    private static final String PROP_AUTH_TOKEN_EXPIRY_HOURS = "auth.token.expiry.hours";
    
    /**
     * Private constructor for singleton pattern
     */
    private SessionAuthenticationManager() {
        this.apiConfig = new ApiConfig();
        String baseUrl = apiConfig.getBaseUrl();
        
        // Initialize session-aware request specification with browser-like cookies
        initializeSessionSpec();
        
        // Initialize authentication manager with sessionSpec via constructor
        this.authManager = new AuthenticationManager(baseUrl, sessionSpec);
    }
    
    /**
     * Get singleton instance with double-checked locking
     */
    public static SessionAuthenticationManager getInstance() {
        if (instance == null) {
            lock.lock();
            try {
                if (instance == null) {
                    instance = new SessionAuthenticationManager();
                    logger.logInfo("SessionAuthenticationManager instance created");
                }
            } finally {
                lock.unlock();
            }
        }
        return instance;
    }
    
    /**
     * Get authentication token for session
     * Automatically authenticates if token not cached and auto-generation is enabled
     */
    public String getSessionAuthToken() {
        String sessionKey = "default_session";
        return getSessionAuthToken(sessionKey);
    }
    
    /**
     * Get authentication token for specific session
     * Always uses cached token if available and not expired
     */
    public String getSessionAuthToken(String sessionKey) {
        // Check for cached, non-expired token first
        SessionAuthData cachedAuth = sessionCache.get(sessionKey);
        if (cachedAuth != null && !cachedAuth.isExpired()) {
            logger.logDebug("Using cached auth token for session: " + sessionKey);
            return cachedAuth.getBearerToken();
        }
        
        // No cached token available, generate new one
        logger.logInfo("Generating new authentication token for session: " + sessionKey);
        return generateAndCacheToken(sessionKey);
    }
    
    /**
     * Generate and cache new authentication token
     */
    private String generateAndCacheToken(String sessionKey) {
        lock.lock();
        try {
            // Double-check if token was generated by another thread
            SessionAuthData cachedAuth = sessionCache.get(sessionKey);
            if (cachedAuth != null && !cachedAuth.isExpired()) {
                logger.logDebug("Token was generated by another thread for session: " + sessionKey);
                return cachedAuth.getBearerToken();
            }
            
            // Get user configuration
            String loginId = getLoginId();
            String clientId = apiConfig.getProperty(PROP_AUTH_USER_CLIENT_ID, "iximweb");
            String deviceId = getDeviceId();
            
            logger.logInfo("Authenticating user: " + loginId + " with client: " + clientId + " for session: " + sessionKey);
            
            // Perform authentication
            AuthResponse response = authManager.authenticate(loginId, clientId, deviceId);
            
            if (response.isSuccess()) {
                // Get configurable expiry duration
                int expiryHours = apiConfig.getIntProperty(PROP_AUTH_TOKEN_EXPIRY_HOURS, 24);
                long expiryDuration = expiryHours * 60 * 60 * 1000L; // Convert hours to milliseconds
                
                // Cache the authentication data
                SessionAuthData authData = new SessionAuthData(
                    response.getAccessToken(),
                    response.getCookie(),
                    System.currentTimeMillis(),
                    expiryDuration
                );
                
                sessionCache.put(sessionKey, authData);
                logger.logInfo("Authentication successful and cached for session: " + sessionKey);
                
                return response.getBearerToken();
            } else {
                logger.logError("Authentication failed for session: " + sessionKey + " - " + response.getMessage(), null);
                throw new RuntimeException("Authentication failed: " + response.getMessage());
            }
            
        } finally {
            lock.unlock();
        }
    }
    
    /**
     * Get login ID from configuration (email or phone)
     */
    private String getLoginId() {
        String email = apiConfig.getProperty(PROP_AUTH_USER_EMAIL);
        String phone = apiConfig.getProperty(PROP_AUTH_USER_PHONE);
        
        // Prefer email if both are configured
        if (email != null && !email.trim().isEmpty()) {
            return email.trim();
        } else if (phone != null && !phone.trim().isEmpty()) {
            return phone.trim();
        } else {
            throw new RuntimeException("No login ID configured. Set either " + PROP_AUTH_USER_EMAIL + " or " + PROP_AUTH_USER_PHONE);
        }
    }
    
    /**
     * Get device ID from configuration or generate new one
     */
    public String getDeviceId() {
        String deviceId = apiConfig.getProperty(PROP_AUTH_USER_DEVICE_ID);
        
        if (deviceId == null || deviceId.trim().isEmpty() || "auto-generated".equals(deviceId)) {
            deviceId = AuthenticationManager.generateDeviceId();
            logger.logDebug("Generated new device ID: " + deviceId);
        }
        
        return deviceId;
    }
    
    
    /**
     * Clear session authentication cache
     */
    public void clearSessionCache() {
        sessionCache.clear();
        logger.logInfo("Session authentication cache cleared");
    }
    
    /**
     * Clear specific session authentication
     */
    public void clearSession(String sessionKey) {
        SessionAuthData removed = sessionCache.remove(sessionKey);
        if (removed != null) {
            logger.logInfo("Cleared authentication for session: " + sessionKey);
        }
    }
    
    /**
     * Check if session has valid authentication
     */
    public boolean hasValidSession(String sessionKey) {
        SessionAuthData authData = sessionCache.get(sessionKey);
        return authData != null && !authData.isExpired();
    }
    
    /**
     * Get session authentication data
     */
    public SessionAuthData getSessionData(String sessionKey) {
        return sessionCache.get(sessionKey);
    }
    
    /**
     * Force re-authentication for session
     */
    public String forceReauthentication(String sessionKey) {
        clearSession(sessionKey);
        return generateAndCacheToken(sessionKey);
    }
    
    /**
     * Get the session-aware RequestSpecification for API calls
     * This ensures all API calls share the same session and cookies
     */
    public RequestSpecification getSessionSpec() {
        return sessionSpec;
    }
    
    /**
     * Initialize session specification with browser-like cookies
     */
    private void initializeSessionSpec() {
        // Configure RestAssured with base URL
        RestAssured.baseURI = apiConfig.getBaseUrl();
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
        
        // Initialize browser-like cookies
        Map<String, String> browserCookies = createBrowserLikeCookies();
        
        // Initialize session specification with cookies
        sessionSpec = RestAssured.given().cookies(browserCookies);
        
        logger.logDebug("SessionSpec initialized with " + browserCookies.size() + " browser-like cookies");
    }
    
    /**
     * Create cookies that would normally exist in a browser session
     */
    private Map<String, String> createBrowserLikeCookies() {
        Map<String, String> browserCookies = new HashMap<>();
        
        try {
            // Get client configuration
            String clientId = apiConfig.getProperty("auth.user.clientid", "ixiweb");
            String deviceId = getDeviceId();
            
            // Session and client identification cookies
            browserCookies.put("session_id", generateSessionId());
            browserCookies.put("clientId", clientId);
            browserCookies.put("appVersion", "0");
            
            // Device and tracking cookies
            if (deviceId != null) {
                browserCookies.put("ixiUID", deviceId);
            }
            
            // Source tracking (similar to what's sent as headers)
            String ixiSrc = apiConfig.getProperty("api.ixisrc");
            if (ixiSrc != null) {
                browserCookies.put("ixiSrc", ixiSrc);
            } else {
                // Default ixiSrc value similar to headers
                browserCookies.put("ixiSrc", "OlU2eQjHHVi4a5rBDGvGCoXqLv9yx+c2xLlH6/r+rwuoEiKF1yqyaNWvRaKNiuLqwrsBn/NXJAQEuWuH7v1JVOwX+yUlpzuP");
            }
            
            // Locale and region cookies
            browserCookies.put("ncr", "IN");
            browserCookies.put("ixiUsrLocale", "urgn=Delhi:ucnc=IN:ucty=Delhi:uctz=Asia/Kolkata:cnc=IN:cc=INR:lng=en");
            
            // Analytics and tracking cookies (simulated)
            browserCookies.put("_ga", "GA1.2.187673094." + System.currentTimeMillis());
            browserCookies.put("_gid", "GA1.2.1284919466." + System.currentTimeMillis());
            
            logger.logDebug("Created " + browserCookies.size() + " browser-like cookies: " + browserCookies.keySet());
            
        } catch (Exception e) {
            logger.logWarning("Failed to create browser-like cookies: " + e.getMessage());
        }
        
        return browserCookies;
    }
    
    /**
     * Generate a session ID similar to browser behavior
     */
    private String generateSessionId() {
        return "sy" + Long.toHexString(System.currentTimeMillis()).substring(6);
    }
    
    /**
     * Inner class to hold session authentication data
     */
    public static class SessionAuthData {
        private final String accessToken;
        private final String cookie;
        private final long timestamp;
        private final long expiryDuration;
        
        public SessionAuthData(String accessToken, String cookie, long timestamp, long expiryDuration) {
            this.accessToken = accessToken;
            this.cookie = cookie;
            this.timestamp = timestamp;
            this.expiryDuration = expiryDuration;
        }
        
        public String getAccessToken() {
            return accessToken;
        }
        
        public String getBearerToken() {
            return accessToken != null ? "Bearer " + accessToken : null;
        }
        
        public String getCookie() {
            return cookie;
        }
        
        public boolean isExpired() {
            return (System.currentTimeMillis() - timestamp) > expiryDuration;
        }
        
        public long getRemainingTime() {
            long elapsed = System.currentTimeMillis() - timestamp;
            return Math.max(0, expiryDuration - elapsed);
        }
    }
}